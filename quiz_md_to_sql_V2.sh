#!/usr/bin/env bash
set -euo pipefail
LC_ALL=C.UTF-8

# ========= Non-interactive, strict CLI =========
URL=""
COURSE=""
START=""
OUTFILE=""

usage() {
  cat <<EOF
Usage: $0 --url <github tree url> --course <name> --start <N> --output <path>
  --url      ex: https://github.com/<owner>/<repo>/tree/<branch>/<subdir>
  --course   course name stored in SQL
  --start    first question number (integer)
  --output   output .sql file path
EOF
}

# Parse strictly
while [ $# -gt 0 ]; do
  case "$1" in
    --url)    shift; URL="${1-}" ;;
    --course) shift; COURSE="${1-}" ;;
    --start)  shift; START="${1-}" ;;
    --output) shift; OUTFILE="${1-}" ;;
    -h|--help) usage; exit 0 ;;
    *) echo "[FAIL] Unknown flag: $1" >&2; usage; exit 2 ;;
  esac
  shift || true
done

# Validate
[ -n "${URL}" ]     || { echo "[FAIL] --url is required" >&2; usage; exit 2; }
[ -n "${COURSE}" ]  || { echo "[FAIL] --course is required" >&2; usage; exit 2; }
[[ "${START}" =~ ^[0-9]+$ ]] || { echo "[FAIL] --start must be integer" >&2; usage; exit 2; }
[ -n "${OUTFILE}" ] || { echo "[FAIL] --output is required" >&2; usage; exit 2; }

echo "=========================================="
echo "   QUIZ .md  ->  H2 SQL (strict non-interactive)"
echo "=========================================="
echo "  [OK] URL='${URL}'"
echo "  [OK] COURSE='${COURSE}'"
echo "  [OK] START=${START}"
echo "  [OK] OUT='${OUTFILE}'"

# ========= Requirements =========
for b in git awk sed grep find ssh; do
  command -v "$b" >/dev/null 2>&1 || { echo "[FAIL] Missing dependency: $b" >&2; exit 1; }
done

# ========= Parse URL =========
u="${URL#*github.com/}"         # <owner>/<repo>/tree/<branch>/...
owner="${u%%/*}"; r="${u#*/}"
repo="${r%%/*}"; r="${r#*/}"    # r = tree/<branch>/...
r="${r#tree/}"                  # r = <branch>/...
branch="${r%%/*}"
subdir="${r#*/}"; [ "$subdir" = "$r" ] && subdir=""

# ========= Clone via SSH =========
export GIT_SSH_COMMAND='ssh -o StrictHostKeyChecking=accept-new -o IdentitiesOnly=yes -i ~/.ssh/id_ed25519'
WORKDIR="$(mktemp -d)"
CLONE_DIR="${WORKDIR}/repo"
REMOTE="git@github.com:${owner}/${repo}.git"

echo "  [..] Cloning repo via SSH…"
if git clone --depth 1 --filter=blob:none --branch "$branch" "$REMOTE" "$CLONE_DIR" >/dev/null 2>&1; then
  USED="$branch"
elif git clone --depth 1 --filter=blob:none --branch main "$REMOTE" "$CLONE_DIR" >/dev/null 2>&1; then
  USED="main"
elif git clone --depth 1 --filter=blob:none --branch master "$REMOTE" "$CLONE_DIR" >/dev/null 2>&1; then
  USED="master"
elif git clone --depth 1 --filter=blob:none "$REMOTE" "$CLONE_DIR" >/dev/null 2>&1; then
  USED="$(git -C "$CLONE_DIR" rev-parse --abbrev-ref HEAD 2>/dev/null || echo default)"
else
  echo "[FAIL] Could not clone via SSH (check GitHub SSH key & rights)" >&2
  exit 1
fi
echo "  [OK] Cloned '${repo}' (branch '${USED}')"

TARGET="$CLONE_DIR"; [ -n "$subdir" ] && TARGET="$CLONE_DIR/$subdir"
[ -d "$TARGET" ] || { echo "[FAIL] Path does not exist in repo: $subdir" >&2; exit 1; }
echo "  [OK] Target dir: $TARGET"

# ========= Find quiz.md =========
LIST="${WORKDIR}/quiz_files.txt"
( cd "$TARGET" && find . -type f -name "*quiz.md" | sort > "$LIST" )
[ -s "$LIST" ] || { echo "[FAIL] No *quiz.md found under ${subdir:-<repo-root>}" >&2; exit 1; }
COUNT="$(wc -l < "$LIST" | tr -d ' ')"
echo "  [OK] Found ${COUNT} quiz file(s)"

# ========= Prepare output =========
OUTDIR="$(dirname "$OUTFILE")"
mkdir -p "$OUTDIR"

# Header
{
  printf '%s\n' \
'-- Autogenerated by quiz-md-to-sql (strict non-interactive)' \
'-- Target: H2 Database' \
'CREATE TABLE IF NOT EXISTS STG_QUESTIONS (' \
'  COURSE_NAME VARCHAR(255) NOT NULL,' \
'  QUESTION_NUMBER INT NOT NULL,' \
'  QUESTION_TEXT VARCHAR(4000) NOT NULL' \
');' \
'' \
'CREATE TABLE IF NOT EXISTS STG_OPTIONS (' \
'  COURSE_NAME VARCHAR(255) NOT NULL,' \
'  QUESTION_NUMBER INT NOT NULL,' \
'  OPTION_LABEL VARCHAR(2) NOT NULL,' \
'  OPTION_TEXT VARCHAR(4000) NOT NULL,' \
'  IS_CORRECT BOOLEAN NOT NULL' \
');' \
'' \
'TRUNCATE TABLE STG_OPTIONS;' \
'TRUNCATE TABLE STG_QUESTIONS;' \
''
} > "$OUTFILE"

# ========= AWK parser =========
PARSER="${WORKDIR}/parser.awk"
cat > "$PARSER" <<'AWK'
BEGIN{
  FS=""; OFS="";
  in_code=0; haveQ=0; q=""; global_idx=0;
  delete opt; delete corr;
}
function trim(s){ sub(/^[ \t\r\n]+/,"",s); sub(/[ \t\r\n]+$/,"",s); return s }
function esc(s){ gsub(/\r/,"",s); gsub(/'\''/,"''",s); return s }
function renumber(qtext, num,   rest){
  if (match(qtext, /^[ \t]*([0-9]+)[.)][ \t]*/)) { rest = substr(qtext, RLENGTH+1) } else { rest = qtext }
  return num ". " trim(rest)
}
function flush(){
  if(!haveQ) return;
  qnum_out = start_num + global_idx; global_idx++;
  q_print = renumber(q, qnum_out);

  printf("INSERT INTO STG_QUESTIONS (COURSE_NAME, QUESTION_NUMBER, QUESTION_TEXT)\nVALUES\n    (\'%s\', %d, \'%s\');\n\n", course, qnum_out, esc(q_print));

  printf("INSERT INTO STG_OPTIONS (COURSE_NAME, QUESTION_NUMBER, OPTION_LABEL, OPTION_TEXT, IS_CORRECT)\nVALUES\n");
  for(i=1;i<=4;i++){
    lbl = sprintf("%c", 64+i);
    txt = (lbl in opt) ? opt[lbl] : "";
    isok = (lbl in corr) ? "TRUE" : "FALSE";
    printf("    (\'%s\', %d, \'%s\', \'%s\', %s)%s\n", course, qnum_out, lbl, esc(txt), isok, (i<4?",":";"));
  }
  print "";

  haveQ=0; q=""; delete opt; delete corr;
}
{
  line=$0
  if(match(line,/^```/)){ in_code = !in_code; next }
  if(in_code) next
  if(match(line,/^[ \t]*---[ \t]*$/)) next

  # question "N. text"
  if(match(line,/^[ \t]*([0-9]+)\.[ \t]+(.*)$/)){
    flush(); q = trim($0); haveQ=1; next
  }

  # option "A) text" (A–D)
  if(match(line,/^[ \t]*([A-Za-z])\)[ \t]+(.*)$/, m)){
    lbl = toupper(m[1]); txt = trim(m[2])
    if(lbl ~ /^[A-D]$/){ opt[lbl]=txt }
    next
  }

  # answer "Rätt svar: B" eller "Rätt svar: B, D"
  if(match(line,/[Rr][äa]tt svar:[ \t]*([A-Za-z][A-Za-z, \t]*)/, m)){
    ans = m[1]; gsub(/[ \t]/,"",ans); n = split(ans, arr, /,/)
    for(i=1;i<=n;i++){ lbl = toupper(arr[i]); if(lbl ~ /^[A-D]$/){ corr[lbl]=1 } }
    next
  }
}
END{ flush() }
AWK

# ========= Run parser =========
cd "$TARGET"
TO_PARSE="${WORKDIR}/run.awk.sh"
printf "awk -v course='%s' -v start_num='%s' -f '%s'" "$COURSE" "$START" "$PARSER" > "$TO_PARSE"
while IFS= read -r f; do printf " '%s'" "$f" >> "$TO_PARSE"; done < "$LIST"
printf " >> '%s'\n" "$OUTFILE" >> "$TO_PARSE"
bash "$TO_PARSE"

cd - >/dev/null 2>&1 || true
echo "  [OK] SQL generated → ${OUTFILE}"
